From fc8bb8d6ae2d4cd024546e9e7bbab115427c3f41 Mon Sep 17 00:00:00 2001
From: Shubham Agrawal <shuagr@microsoft.com>
Date: Fri, 11 Oct 2019 20:20:18 +0000
Subject: [PATCH] sqlite3 CVE: CVE-2019-16168 
Reply-To: shuagr@microsoft.com


CVE:CVE-2019-16168
Status: Backport

whitelist as changes already there due to previous patches in upstream
CVE:CVE-2018-20346
Status: Backported

Signed-off-by: Shubham Agrawaslshuagr@microsoft.com

---
 sqlite3.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/sqlite3.c b/sqlite3.c
index 0f71a44..c480e53 100644
--- a/sqlite3.c
+++ b/sqlite3.c
@@ -101836,7 +101836,9 @@ static void decodeIntArray(
       if( sqlite3_strglob("unordered*", z)==0 ){
         pIndex->bUnordered = 1;
       }else if( sqlite3_strglob("sz=[0-9]*", z)==0 ){
-        pIndex->szIdxRow = sqlite3LogEst(sqlite3Atoi(z+3));
+        int sz = sqlite3Atoi(z+3);
+        if( sz<2 ) sz = 2;
+        pIndex->szIdxRow = sqlite3LogEst(sqlite3Atoi(sz));
       }else if( sqlite3_strglob("noskipscan*", z)==0 ){
         pIndex->noSkipScan = 1;
       }
@@ -137151,6 +137153,7 @@ static int whereLoopAddBtreeIndex(
     ** it to pNew->rRun, which is currently set to the cost of the index
     ** seek only. Then, if this is a non-covering index, add the cost of
     ** visiting the rows in the main table.  */
+    assert( pSrc->pTab->szTabRow>0 );
     rCostIdx = pNew->nOut + 1 + (15*pProbe->szIdxRow)/pSrc->pTab->szTabRow;
     pNew->rRun = sqlite3LogEstAdd(rLogSize, rCostIdx);
     if( (pNew->wsFlags & (WHERE_IDX_ONLY|WHERE_IPK))==0 ){
-- 
2.7.4

